"""
题目描述:
给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。
如果你最多只允许完成一笔交易（即买入和卖出一支股票一次），设计一个算法来计算你所能获取的最大利润。
注意：你不能在买入股票前卖出股票。

示例：
输入: [1,2,3,1]
输出: 4
解释: 偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。
     偷窃到的最高金额 = 1 + 3 = 4 。

解题思路 使用“状态穷举”团灭6道股票问题。对于本题，每天都有三种「选择」：买入、卖出、无操作，且只允许交易一次
我们可以定义一个三维数组 dp 穷举这三种状态：dp[i][k][0 or 1]；第一个i是天数，第二个k是允许交易的最大次数，第三个是当前的持有状态（1-持有，0-未持有）

例如：dp[3][2][1] 的含义就是：今天是第三天，我现在手上持有股票，至今最多进行 2 次交易
状态转移:
(1)今天我没有持有股票，有两种可能：
   我昨天就“没有持有”，然后今天“不操作”，所以我今天还是“没有持有”；
   我昨天“持有”股票，但是今天我“卖出”了，所以我今天“没有持有”股票了
(2)今天我持有着股票，有两种可能：
   我昨天就“持有”股票，然后今天选择“不操作”，所以我今天还“持有”股票；
   我昨天本“没有持有”，但今天我选择“买入”，所以今天我就“持有”股票了
"""
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        
        dp_i_0 = 0 # 第 i 天没有持股
        dp_i_1 = -float('inf') # 第 i 天持有股票，一开始初始化为负无穷(第0天)
        for p in prices:
            dp_i_0 = max(dp_i_0, dp_i_1 + p)
            # 注意！因为只允许走一次交易，所以隐状态中有 k=1 的约束
            # k = 0 表示不允许有任何交易
            # dp[i][0][0] = 0, dp[i][0][1] = -inf
            dp_i_1 = max(dp_i_1, 0-p)
            # 如果不限制交易次数，则 dp_i_1 更新为:
            # dp_i_1 = max(dp_i_1, dp_i_0 - p)
        print(dp_i_0, dp_i_1)
        return dp_i_0
