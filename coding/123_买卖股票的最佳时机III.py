"""
题目描述：
给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。
设计一个算法来计算你所能获取的最大利润。你最多可以完成 两笔 交易。
注意: 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

示例：
输入: [3,3,5,0,0,3,1,4]
输出: 6
解释: 在第 4 天（股票价格 = 0）的时候买入，在第 6 天（股票价格 = 3）的时候卖出，这笔交易所能获得利润 = 3-0 = 3 。
     随后，在第 7 天（股票价格 = 1）的时候买入，在第 8 天 （股票价格 = 4）的时候卖出，这笔交易所能获得利润 = 4-1 = 3 。

解题思路：
依然采用穷举所有状态的套路。限制了交易次数为2次，所以要考虑（穷举）交易次数k。
借助4个变量来穷举所有可能的状态（天数i，交易次数k，是否持有股票）：
dp_i_1_0 = 0     # 到第i天进行了1次交易，且手上没有股票
dp_i_2_0 = 0     # 到第i天进行了2次交易，且手上没有股票
dp_i_1_1 = -1e10 # 到第i天进行了1次交易，且手上有股票(初始为负无穷)
dp_i_2_1 = -1e10 # 到第i天进行了2次交易，且手上有股票(初始为负无穷)
"""
class Solution:
    def maxProfit(self, prices: List[int]) -> int:

        dp_i_1_0 = 0 
        dp_i_2_0 = 0 
        dp_i_1_1 = -1e10 
        dp_i_2_1 = -1e10 
        
        # 依然穷举所有状态（考虑交易次数 k）
        # k的含义: 到第 i 天时，至今进行了 k 次交易
        for p in prices:
            # 买入、卖出时 计算一次交易即可
            # 这里在买入股票时，算作一次交易（k-1）
            tmp = dp_i_1_0
            # 穷举 k=1 的情况
            dp_i_1_0 = max(dp_i_1_0, dp_i_1_1 + p)
            dp_i_1_1 = max(dp_i_1_1, 0 - p)
            # 穷举 k=2 的情况
            dp_i_2_0 = max(dp_i_2_0, dp_i_2_1 + p)
            dp_i_2_1 = max(dp_i_2_1, tmp - p)

        return dp_i_2_0 # k 越大，交易次数越多，最终收益也越大
